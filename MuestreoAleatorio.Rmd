---
title: "TallerMuestreoAleatorio"
author: "Sebastian Chaparo J"
date: '2022-10-07'
output: pdf_document
---

```{r setup, include= FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning =   FALSE)
knitr::opts_chunk$set(message =   FALSE)
library(knitr)
library(dplyr)
library(ggplot2)
library(samplingbook)
TSLA <- read.csv("Corte 2/TSLA.csv")
```

# Contexto.

Se dispone de la base de datos de Cierres de TESLA para el año 2010 a 2022, la cual cuenta con las siguientes variables.

```{r}
colnames(TSLA)
```

-   Date : Fecha
-   Open : Precio cuando abre el mercado
-   High : Precio más alto registrado para el día
-   Low : Precio más bajo registrado para el día
-   Close : Precio cuando el mercado cierra
-   Adj.Close : Precio de cierre modificado basado en acciones corporativas
-   volume : Cantidad de acciones vendidas en un día.

Con la información disponible se busca realizar un muestreo aleatorio simple para el Adj.Close

# Analisis descriptivo Adj.Close

## Resumen descriptivo

```{r}
resumen <-  as.array(summary(TSLA$Adj.Close))  
kable(resumen , col.names = c("Descriptivo", "Valor"), digits = 2)   
```

## Distribucion de la variable

```{r fig.height= 3}
plot(density(TSLA$Adj.Close), main = "Distribucion" )
```

La variable en estudio no es normal, por lo tanto, los estadísticos paramétricos no tendrán mucha efectividad. Por fines académicos, asumimos una distribución normal.

```{r, fig.height=3}
boxplot(x = TSLA$Adj.Close ,horizontal = T)
```

```{r}
atipicos <- boxplot.stats(TSLA$Adj.Close)$out
N.atipico <- length(atipicos)
Faltantes <- sum(is.na(TSLA$Adj.Close))
```

Valores atípicos, en total : `r N.atipico`.

Valores Faltantes : `r Faltantes`.

Supongamos que la empresa quiere realizar un estudio de los días en que el cierre ajustado consideraron atípicos, para ello, requiere de personal y tiempo. Ya se dispone de la base datos y se pueden filtrar estos valores, sin embargo, Realizar un estudio de las 635 observaciones, requiere de tiempo y personal, para ello se realiza un muestreo aleatorio simple.

```{r}
TSLA.1 <- TSLA %>% filter(Adj.Close %in% atipicos)

N <- nrow(TSLA.1)
```

### Distribucion de los valores atipicos


```{r}
par(mfrow = c(2,1))
plot(density(TSLA.1$Adj.Close),main ="Distribucion  de los valores atipos Adj.close")
boxplot(TSLA.1$Adj.Close)
```


# Diseño del muestreo aleatorio simple.

## Eleccion de la prueba piloto

```{r}
n.0 <- round(0.1*nrow(TSLA.1),0)
n <- round(1.1*n.0,0)
```

Para seleccionar la prueba piloto teóricamente se recomienda seleccionar una muestra del 0.1% lo cual equivale a `r n.0` + un 10% de esta muestra en caso de perder o dañar la información. El tamaño de la muestra piloto es de `r n`.

```{r}
set.seed(13)
id.muestra <- sample(1:635,size = n,  replace = F)
muestra <- TSLA.1[id.muestra,]
kable(muestra[1:5,],caption = "Primeras 5 observaciones de la muestra piloto seleccionada",digits = 3)
```
```{r}
hist(muestra$Adj.Close,30)
```
La eleccion de la muestra piloto claramento no tiene una distribucion normal, Por lo tanto, sería aconsejable utilizar estadísticas no paramétricas que nos permitan inferir sobre el posible estimador poblacional, como es necesario tener conocimiento de la media y la sd estándar, sé realizar una primera estimación de estos por un método no paramétrico denominado boostrap.









```{r}
boostrap.media <- rep(NA,9999)
boostrap.sd <- rep(NA,9999)
set.seed(123)
for(i in 1:9999){
  muestras <- sample(muestra$Adj.Close, replace = T)
  boostrap.sd[i] <- sd(muestras)
  boostrap.media[i] <- mean(muestras)
  
}

Media.boostrap <- mean(boostrap.media) 
sd.boostrap <- mean(boostrap.sd)
hist(boostrap.media,breaks = 30,probability = T)

```

De acuerdo a la gráfica obtenida  el boostrap se distribuye de manera normal. Recordando el teorema del límite central, podemos asumir que las medias de esta distribución serán un estimador del parámetro poblacional de la media aritmética de la población, esto como un primer acercamiento al parámetro.


Media: `r Media.boostrap`.   
Sd: `r sd.boostrap`



## Eleccion del tamaño muestral

Una vez seleccionada la muestra piloto podemos determinar el error con el cual trabajar y el tamaño de la muestra para ser representativo de la población. Para el error se recomienda que no sobrepase $0.1(\mu)$ de la muestra piloto

```{r}

Error <- Media.boostrap*0.1
Error.seq <- seq(0 ,Error, Error/20 )
Ns <- 0.05
z <- qnorm(1 - 0.05/2)
posibles.n <- ((z^2)*sd.boostrap^2)/Error.seq^2  # Para poblacion infinita  
posibles.n.corre <-  posibles.n/(1+(posibles.n/N))
Tabla2 <- cbind(Error.seq, posibles.n, posibles.n.corre)
kable(Tabla2 ,col.names = c("Error", "n (N inf)", "n"),digits = 2)
```

El cálculo anterior se puede realizar de manera más sencilla con la librería ´samplingbook´

```{r}
library(samplingbook)
resulatado <- rep(NA,length(Error.seq))
err.1 <-  rep(NA,length(Error.seq))
for( i in 1:length(Error.seq) ){
  resulatado[i] <-  sample.size.mean(Error.seq[i], sd.boostrap, 635)$n  
  err.1[i] <- Error.seq[i]
}

kable(cbind(resulatado,err.1) ,digits = 3 , col.names = c("N", "Error") ) 
```

```{r ,fig.width=8}
plot(y=err.1, x= resulatado ,ylab = "Error" , xlab = "N")

```
```{r}
sample.size.mean(e = 4.3184,S =    sd.boostrap ,N = 635,    level = 0.95)
```



Para un error de 4.3184(2\%)con un nivel de confianza del 95% se requiere de una muestra de 471  fechas registradas de valores atipicos  de adj.close 

```{r}
id.sample2 <- sample(1:635,size = 471, replace = F) 
muestra.final <- TSLA.1[id.sample2,]
```
Al determinar el intervalo de confianza del 95\%  se puede evidenciar que si se cumple el criterio del error, es decir, se estima que la media es $219.6699 \pm 4.1283$  valor que se aproxima muy bien al propuesto de 4.3184


```{r}
Smean(muestra.final$Adj.Close, N = 635 , level = 0.95)
```
Se puede realizar una comparación con la verdadera media poblacional 

```{r}
mean(TSLA.1$Adj.Close)
```
La cual se encuentra en el intervalo de la muestra seleccionada  [215.5417,223.7982]


Se puede comprobar lo mismo para diferentes tamaño muestrales, supongamos un error del 5% equivalente a 10.79 segun la prueba piloto 


```{r}
sample.size.mean(e = 10.79,S =    sd.boostrap ,N = 635,    level = 0.95)
```

```{r}
id.sample2 <- sample(1:635,size = 200, replace = F) 
muestra.final <- TSLA.1[id.sample2,]
Smean(muestra.final$Adj.Close, N = 635 , level = 0.95)
```




